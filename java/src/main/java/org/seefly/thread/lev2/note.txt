简述jmm
    在java内存模型中线程总是从主存中读取数据到本地内存中进行操作，所以会造成一个线程修改了变量之后，另一个
线程还在使用本地内存中的值进行操作。这种情况可以使用Volatile关键字解决，即告诉jvm这个变量是不稳定的
每次读取都要到主存中拿，同时它还防止了指令重排序。


java内存模型我的理解是可以分为两个部分
一个是多线程共享的部分，一个是线程私有的部分
多线程共享的部分有堆和方法区
堆中存放的都是java实例，例如当我们创建了一个对象之后，会将这个对象放到堆内存中
而方法区则是存放了我们加载的类的信息，例如类的方法信息、构造函数信息等。

而线程私有的则包含虚拟机栈、程序计数器、本地方法栈。
    虚拟机栈可以理解为一个线程执行时方法调用的过程，每执行一个方法都会产生一个栈帧压入虚拟机栈，一个栈帧包含了当前调用方法的上下文即局部变量表、操作数栈等。
一次方法的调用也就相当于栈帧出栈入栈的过程。
    本地方法栈和虚拟机栈类似，只不过它用来记录本地方法的调用。
    程序计数器总是指向该线程下一次执行命令的地址

多线程数据安全
    由于所有的数据都放在主存中，如果线程需要操作需要复制一份到线程的本地内存中进行操作，这时候如果多个线程对
同一份数据进行更新，那么则会出现数据紊乱。
    所以需要从三个方面防止这个问题
    1、原子性
        即一个线程对数据的更新操作，其他线程要么看到更新未开始，要么看到更新后的结果，不能看到更新过程。
        java中可以使用锁来实现这种功能，保证同一个变量同一时刻只能有一个线程访问。
    2、可见性
        如果一个线程对某个共享变量进行更新之后，后续访问该变量的线程可以读取到该更新的结果，那么就称这个线程对该共享变量的更新对其他线程可见，
        否则就称这个线程对该共享变量的更新对其他线程不可见。
        为什么会出现不可见呢？因为线程工作所需要的数据是要从主存中取的，再在本地内存中进行操作，然后更新到主存中。虽然保证了原子性，但操作结果也需要保证。
    3、有序性
        重排序是对内存访问操作的一种优化，他可以在不影响单线程程序正确性的前提下进行一定的调整，进而提高程序的性能
        但是对于多线程场景下，就可能产生一定的问题




垃圾回收
https://mp.weixin.qq.com/s/JjPKuJlkpI10aVCbPfnWKQ