1、https://juejin.im/post/5b29d2c4e51d4558b80b1d8c
2、https://www.cnblogs.com/buxiangxin/p/8336022.html

TCP三次握手
1、三次握手的过程
    第一次握手，即请求端首先发送一个SYN=1同步标志位，以及自己的序列号seq=x
        SYN标志位代表此时收发双方正在进行序列号同步，seq表示自己当前发送的数据在整个发送期间的位置
    第二次握手为接收端的响应，其中包括ACK=1,SYN=1，seq=y,ack=x+1
        ACK=1标志位标识已收到对方发送的数据，seq=y同上，不过代表的是己方发送序列号。ack=x+1表示已经收到对方
        x位序列，期望下次收到第x+1位序列
    第三次握手
        ACK=1,seq=x+1,ack=y+1
2、为什么是三次握手，不是四次不是两次？
    以客户端主动向服务端发起连接请求为例
    客户端主动向服务器发送连接请求，这是第一次握手
    服务端收到连接请求后回应第二次握手。
    这两次握手可以确认的是，客户端知道自己的发送和接收都没有问题。
    而服务端只能知道可以接收到客户端发送的数据，由于没有第三次握手所以并不知道自己和客户端的通讯有没有问题。
    所以两次握手没办法保证通讯双方都能确认彼此的收发都是OK的。

    由于三次握手是理论上能够确定通讯双方的通讯能力都没有问题的最小次数，所以四次握手是浪费的。

TCP四次挥手
1、四次挥手的过程
    由于TCP是全双工的，所以通讯双方都可以同时收发数据。如果一方想要断开连接就要有一种机制
    来确保不会发生问题。
    1、假如客户端想要主动断开连接，那么它会向服务器发送断开连接标志，通知服务器它要断开连接了，同时
        停止主动发送数据，并将自己的状态置为FIN_WAIT_1状态
    2、服务端收到FIN标志位后就知道客户端已经将数据发送完毕了需要断开连接，此时服务端会回应一个ack告诉
        客户端你的断开请求我收到了，并将自己的状态置为CLOSE_WAIT状态。但服务端此时还是可以发送数据的。
        客户端在收到这个ACK后将自己的状态置为FIN_WAIT_2
    3、服务端在所有的数据都发送完毕之后会向客户端发送一个FIN 标志，告诉客户端数据已经发送完毕可以关闭连接了。
        然后将自己的状态置为LAST_ACK
    4、客户端收到客户端的FIN信号后，知道服务端已经将数据都发完了，此时会回应一个ACK。然后将自己置为TIME_WAIT状态
        TIME_WAIT状态会持续两个最大报文寿命时长，目的就是防止最后一个ACK丢失，服务器会重发FIN信息，以及保证所有
        由于链路问题还在网络上转发的数据包到达后都能被丢弃，防止影响下一个连接。
