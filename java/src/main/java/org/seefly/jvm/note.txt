java内存模型(jmm:java memory model)和jvm内存模型
    这两个不是一个东西，java内存模型是一种规范定义，描述了多个线程之间是如何进行通讯的。
    而jvm内存模型(内存划分)很直白的就是说jvm里面的各个内存区域都是干啥的。

java内存模型
        由于java里面的多线程通讯是通过主存也就是共享内存来通讯的，而jmm规定每个线程不能直接操作
    主存中的变量，必须有一个自己的工作内存。也就是说想要操作这个共享的变量必须先把它读到自己的工作
    内存中，更新完毕之后再写回主存，而且线程和线程不能访问彼此的工作线程。但是这样就会产生数据一致性的问题
    也就是我们说的线程安全问题，java内存模型对于这种情况从三个方面进行处理
    1、原子性
        一个线程对共享数据的操作，其他线程要么看到这个数据还未开始更新，要么看到已经更新后的结果，不能看到更新过程。
    2、可见性
        一个线程对共享数据进行了更新，后面其他线程在访问的时候必须是可见的。
    3、有序性
        重排序是对内存访问操作的一种优化，他可以在不影响单线程程序正确性的前提下进行一定的调整，进而提高程序的性能
        但是对于多线程场景下，就可能产生一定的问题

简述jmm
    在java内存模型中线程总是从主存中读取数据到本地内存中进行操作，所以会造成一个线程修改了变量之后，另一个
线程还在使用本地内存中的值进行操作。这种情况可以使用Volatile关键字解决，即告诉jvm这个变量是不稳定的
每次读取都要到主存中拿，同时它还防止了指令重排序。


jvm内存模型我的理解是可以分为两个部分
一个是多线程共享的部分，一个是线程私有的部分
多线程共享的部分有堆和方法区
    堆中存放的都是java实例，例如当我们创建了一个对象之后，会将这个对象放到堆内存中
    而方法区则是存放了我们加载的类的信息，例如类的方法信息、构造函数信息等。

而线程私有的则包含虚拟机栈、程序计数器、本地方法栈。
    虚拟机栈可以理解为一个线程执行时方法调用的过程，每执行一个方法都会产生一个栈帧压入虚拟机栈，一个栈帧包含了当前调用方法的上下文即局部变量表、操作数栈等。
一次方法的调用也就相当于栈帧出栈入栈的过程。
    本地方法栈和虚拟机栈类似，只不过它用来记录本地方法的调用。
    程序计数器总是指向该线程下一次执行命令的地址



垃圾回收
https://mp.weixin.qq.com/s/JjPKuJlkpI10aVCbPfnWKQ