## 事务的隔离级别

### 一、ACID

1.  **原子性(Atomic)** 

   事务中包含的操作，被看作是一个整体的业务单元，这个业务单元中的操作要么全部成功，要么全部失败。

2.  **一致性(Consistency)**

   事务完成时，所有的数据都必须保持一致。

3.  **隔离性(Isolation)**

   隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。

4.  **持久性(Durability)**

   事务结束后所有的数据会持久化到一个地方(内存不算)。

### 二、丢失更新

1.  **第一类丢失更新**

   两个事务并发处理同一件事情，一个提交，一个回滚，回滚的把提交的覆盖了。不过目前绝大多数数据库系统已经克服了第一类丢失更新。

| 时刻 | 事务1             | 事务2              |
| ---- | ----------------- | ------------------ |
| T1   | 初始库存100       | 初始库存100        |
| T2   | 扣减库存，余99    |                    |
| T3   |                   | 扣减库存，余99     |
| T4   |                   | 提交事务，库存为99 |
| T5   | 回滚事务，库存100 |                    |

2.  **第二类丢失更新**

   两个事务并发处理同一间事情，两个事务先后提交。那么后提交的事务覆盖了先提交的事务的执行结果

| 时刻 | 事务1            | 事务2            |
| ---- | ---------------- | ---------------- |
| T1   | 初始库存100      | 初始库存100      |
| T2   | 扣减库存，余99   |                  |
| T3   |                  | 扣减库存，余99   |
| T4   |                  | 提交事务，库存99 |
| T5   | 提交事务，库存99 |                  |



### 三、隔离级别

1. **读未提交**

   这是最低的隔离级别会出现**<u>脏读现象</u>**，就是允许一个事务读取另一个事务还没有提交的数据。这种割隔离级别的缺点是根本不会保证数据的一致性，但好在并发量大。

####  脏读现象

| 时刻 | 事务1                                   | 事务2           |
| ---- | --------------------------------------- | --------------- |
| T1   | 初始库存2                               | 初始库存2       |
| T2   | 扣减库存，余1                           |                 |
| T3   |                                         | 读取库存，1     |
| T4   |                                         | 扣减库存，余0   |
| T5   |                                         | 提交事务，库存0 |
|      | 回滚事务，库存0。第一类丢失更新已被克服 |                 |

2.  **读已提交**

   是指一个事务只能读取另一个事务已经提交的数据，不能读取未提交的数据。所以它避免了脏读，但是会出现**不可重复读**的问题。

#### 克服脏读现象

| 时刻 | 事务1                                   | 事务2                 |
| ---- | --------------------------------------- | --------------------- |
| T1   | 初始库存2                               |                       |
| T2   | 扣减库存，余1                           |                       |
| T3   |                                         | 扣减库存，余1         |
| T4   |                                         | 提交事务，持久化库存1 |
| T5   | 回滚事务，第一类丢失更新已被克服。库存1 |                       |

#### 出现不可重复读现象

| 时刻 | 事务1             | 事务2                                                     |
| ---- | ----------------- | --------------------------------------------------------- |
| T1   | 读取库存1         |                                                           |
| T2   | 扣减库存，库存为0 |                                                           |
| T3   |                   | 读取库存1                                                 |
| T4   | 提交事务，库存0   |                                                           |
| T5   |                   | 扣减库存，库存为0。失败！一次事务中两次的访问结果不一致。 |

3.  **可重复读**

   可重复读消除了不可重复读的现象，因为读已提交的时候可能出现一些值的变化，影响当前事务的执行。

#### 克服不可重复读现象

| 时刻 | 事务1             | 事务2                                |
| ---- | ----------------- | ------------------------------------ |
| T1   | 读取库存1         |                                      |
| T2   | 扣减库存，库存为0 |                                      |
| T3   |                   | 尝试读取库存，发现有事务未提交，等待 |
| T4   | 提交事务，库存0   |                                      |
| T5   |                   | 读取库存0,正确！                     |

#### 出现幻读显现

 幻读不是针对一条数据库记录而言，而是多条。而可重复读是针对数据库的单条记录。

| 时刻 | 事务1            | 事务2              | 备注                                        |
| ---- | ---------------- | ------------------ | ------------------------------------------- |
| T1   | 读取库存50件     |                    | 商品库存初始化100，现在已经销售50件，库存50 |
| T2   |                  | 查询交易记录，50笔 |                                             |
| T3   | 扣减库存，余49件 |                    |                                             |
| T4   | 插入1笔交易记录  |                    |                                             |
| T5   | 提交事务         |                    | 库存49件，交易记录51笔。                    |
|      |                  | 打印交易记录，51笔 | 和查询结果不一致，在事务2看来有一个幻读     |

4. 串行化

   串行化是数据库的最高隔离级别，他要求所有的SQL都会按照顺序执行，这样完全保证数据的一致性。但是缺点很明显，就是不能用在高并发场景。

